name: Build & Release

on:
  workflow_dispatch:
  pull_request:
    branches:
      - master
      - develop
    paths:
      - "data/**"
      - "mods/**" 
      - "modules/**"
      - "layouts/**"
      - ".github/**"
      - "src/**"
  push:
    branches:
      - master
      - develop
    paths:
      - "data/**"
      - "mods/**"
      - "modules/**"
      - "layouts/**"
      - "src/**"

env:
  CMAKE_BUILD_PARALLEL_LEVEL: 2
  MAKEFLAGS: '-j 2'
  VCPKG_DEFAULT_BINARY_CACHE: ${{ github.workspace }}/vcpkg/bincache
  VCPKG_BINARY_SOURCES: 'clear;default,readwrite'

jobs:
  build:
    name: ${{ matrix.os }}-${{ matrix.buildtype }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: windows-2022
            buildtype: windows-release
            triplet: x64-windows
            artifact-name: otclient-windows.exe
            packages: sccache
          - os: ubuntu-22.04
            buildtype: linux-release
            triplet: x64-linux
            artifact-name: otclient
            packages: sccache
          - os: macOS-14
            buildtype: macos-release
            triplet: x64-osx
            artifact-name: otclient
            packages: sccache

    steps:
    - name: Checkout repository
      uses: actions/checkout@main

    - name: Install Linux Dependencies
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y libgl1-mesa-dev xorg-dev libasound2-dev libglu1-mesa-dev freeglut3-dev mesa-common-dev
        # libx11-dev libxcb1-dev libx11-xcb-dev

    - name: Install macOS Dependencies
      if: runner.os == 'macOS'
      run: |
        brew install xquartz
        brew install libx11
        brew install libxext
        brew install openal-soft
        brew install physfs
        brew install sdl2

    - name: Cache vcpkg packages
      uses: actions/cache@v3
      with:
        path: |
          ${{ github.workspace }}/vcpkg
          !${{ github.workspace }}/vcpkg/buildtrees
          !${{ github.workspace }}/vcpkg/packages
          !${{ github.workspace }}/vcpkg/downloads
        key: vcpkg-${{ runner.os }}-${{ hashFiles('vcpkg.json') }}
        restore-keys: |
          vcpkg-${{ runner.os }}-

    - name: Cache build outputs
      uses: actions/cache@v3
      with:
        path: |
          ${{ github.workspace }}/build/${{ matrix.buildtype }}
          !${{ github.workspace }}/build/${{ matrix.buildtype }}/CMakeCache.txt
          !${{ github.workspace }}/build/${{ matrix.buildtype }}/CMakeFiles
        key: build-${{ runner.os }}-${{ matrix.buildtype }}-${{ hashFiles('src/**/*.cpp', 'src/**/*.h') }}
        restore-keys: |
          build-${{ runner.os }}-${{ matrix.buildtype }}-

    - name: Create vcpkg binary cache directory
      run: mkdir -p ${{ env.VCPKG_DEFAULT_BINARY_CACHE }}

    - name: Setup vcpkg
      uses: lukka/run-vcpkg@v11
      with:
        vcpkgDirectory: '${{ github.workspace }}/vcpkg'

    - name: Restore artifacts and install vcpkg (Windows)
      if: runner.os == 'Windows'
      id: vcpkg-step-windows
      shell: pwsh
      run: |
        $json=Get-Content vcpkg.json -Raw | ConvertFrom-Json
        $vcpkgCommitId=$json.'builtin-baseline'
        Write-Host "vcpkg commit ID: $vcpkgCommitId"
        echo "vcpkgGitCommitId=$vcpkgCommitId" >> "$env:GITHUB_OUTPUT"

    - name: Restore artifacts and install vcpkg (Unix)
      if: runner.os != 'Windows'
      id: vcpkg-step-unix
      shell: bash
      run: |
        vcpkgCommitId=$(cat vcpkg.json | grep -o '"builtin-baseline": *"[^"]*"' | cut -d'"' -f4)
        echo "vcpkg commit ID: $vcpkgCommitId"
        echo "vcpkgGitCommitId=$vcpkgCommitId" >> $GITHUB_OUTPUT

    - name: Get latest CMake and ninja
      uses: lukka/get-cmake@latest

    - name: Run CMake
      uses: lukka/run-cmake@v10
      with:
        configurePreset: '${{ matrix.buildtype }}'
        buildPreset: '${{ matrix.buildtype }}'

    - name: Create and Upload Artifacts
      uses: actions/upload-artifact@main
      with:
        name: otclient-${{ matrix.os }}-${{ matrix.buildtype }}-${{ github.sha }}
        path: |
          ${{ github.workspace }}/build/${{ matrix.buildtype }}/${{ matrix.artifact-name }}

    - name: Create Client Package (Windows)
      if: runner.os == 'Windows'
      run: |
        $tempDir = "$env:GITHUB_WORKSPACE/client"
        New-Item -Path $tempDir -ItemType Directory -Force
        Copy-Item -Path "$env:GITHUB_WORKSPACE/data" -Destination "$env:GITHUB_WORKSPACE/client/data" -Recurse -Force
        Copy-Item -Path "$env:GITHUB_WORKSPACE/mods" -Destination "$env:GITHUB_WORKSPACE/client/mods" -Recurse -Force  
        Copy-Item -Path "$env:GITHUB_WORKSPACE/modules" -Destination "$env:GITHUB_WORKSPACE/client/modules" -Recurse -Force
        Copy-Item -Path "$env:GITHUB_WORKSPACE/init.lua" -Destination "$env:GITHUB_WORKSPACE/client/init.lua" -Force
        Copy-Item -Path "$env:GITHUB_WORKSPACE/build/${{ matrix.buildtype }}/otclient.exe" -Destination "$env:GITHUB_WORKSPACE/client/otclient.exe" -Force

        # Copy required DLLs from vcpkg
        $vcpkgBinPath = "$env:GITHUB_WORKSPACE/build/${{ matrix.buildtype }}/vcpkg_installed/x64-windows/bin"
        if (Test-Path $vcpkgBinPath) {
            Get-ChildItem -Path $vcpkgBinPath -Filter "*.dll" | ForEach-Object {
                Copy-Item $_.FullName -Destination "$env:GITHUB_WORKSPACE/client/" -Force
            }
        }

        # Copy system DLLs if needed - mainly for VCRUNTIME
        $systemDlls = @(
            "msvcp140.dll",
            "vcruntime140.dll",
            "vcruntime140_1.dll"
        )
        foreach ($dll in $systemDlls) {
            $systemPath = "C:\Windows\System32\$dll"
            if (Test-Path $systemPath) {
                Copy-Item $systemPath -Destination "$env:GITHUB_WORKSPACE/client/" -Force
            }
        }
        Compress-Archive -Path "$env:GITHUB_WORKSPACE/client" -DestinationPath "$env:GITHUB_WORKSPACE/client.zip"

    - name: Create Client Package (Linux)
      if: runner.os == 'Linux'
      run: |
        mkdir -p client
        cp -r data client/
        cp -r mods client/
        cp -r modules client/
        cp init.lua client/
        cp build/${{ matrix.buildtype }}/otclient client/
        chmod +x client/otclient
        tar -czf client.tar.gz client/

    - name: Create Client Package (macOS)
      if: runner.os == 'macOS'
      run: |
        mkdir -p client
        cp -R data client/
        cp -R mods client/
        cp -R modules client/
        cp init.lua client/
        cp build/${{ matrix.buildtype }}/otclient client/
        chmod +x client/otclient
        zip -r client.zip client

    - name: Upload Client Package
      uses: actions/upload-artifact@v4
      with:
        name: client-${{ matrix.os }}-${{ matrix.buildtype }}
        path: |
          ${{ runner.os == 'Windows' && 'client.zip' || runner.os == 'Linux' && 'client.tar.gz' || 'client.zip' }}

  release:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Use Node.js 20.x
        uses: actions/setup-node@v3
        with:
          node-version: '20.x'

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts
          pattern: 'client-*'

      - name: List downloaded artifacts
        run: ls -R artifacts/

      # https://github.com/semantic-release/semantic-release/issues/1592#issuecomment-902533435
      # Semantic-release doesn't support pathing to a config file unless using a .js config:
      # instead copy the file to the root as a workaround to maintain workflow separation
      - name: Copy Release Config to Root
        run: |
          cp .github/.releaserc ./

      - name: Install Semantic Release
        run: |
          npm install semantic-release @semantic-release/github --save-dev
          npm install conventional-changelog-eslint --save-dev

      # Ensure that only one rc pre-release is active at a time by deleting the latest pre-release 
      # and its corresponding tag on the 'develop' branch. This avoids clutter from multiple rc 
      # releases after each merge into the develop branch.
      - name: Delete Existing Pre-release and Tag (Develop Branch Only)
        if: github.ref == 'refs/heads/develop'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          latest_prerelease_tag=$(gh release list --limit 1 --json tagName,isPrerelease \
            --jq '.[] | select(.isPrerelease) | .tagName')

          if [ -n "$latest_prerelease_tag" ]; then
            gh release delete "$latest_prerelease_tag" --yes --cleanup-tag
          fi

      - name: Semantic Release (Dry Run for PRs)
        if: ${{ github.event_name == 'pull_request' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: npx semantic-release --ci --dry-run

      - name: Semantic Release (Full Release on Push)
        if: ${{ github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEBUG: semantic-release:*
        run: |
          npx semantic-release --ci
          RELEASE_TAG=$(gh release list --limit 1 --json tagName --jq '.[0].tagName')
          
          # Windows artifact
          if [ -f "artifacts/client-windows-2022-windows-release/client.zip" ]; then
            gh release upload "$RELEASE_TAG" "artifacts/client-windows-2022-windows-release/client.zip" --clobber \
              --name "otclient-windows-${RELEASE_TAG}.zip"
          fi
          
          # Linux artifact
          if [ -f "artifacts/client-ubuntu-22.04-linux-release/client.tar.gz" ]; then
            gh release upload "$RELEASE_TAG" "artifacts/client-ubuntu-22.04-linux-release/client.tar.gz" --clobber \
              --name "otclient-linux-${RELEASE_TAG}.tar.gz"
          fi
          
          # macOS artifact
          if [ -f "artifacts/client-macOS-14-macos-release/client.zip" ]; then
            gh release upload "$RELEASE_TAG" "artifacts/client-macOS-14-macos-release/client.zip" --clobber \
              --name "otclient-macos-${RELEASE_TAG}.zip"
          fi

      # https://semantic-release.gitbook.io/semantic-release/usage/workflow-configuration#pre-release-branches
      # Semantic-release appends a numerical suffix to all pre-releases by default (e.g., `v0.0.1-rc.1`).
      # Currently, this behavior is not configurable via CLI or the release config. For improved readability 
      # and consistency, this step renames the tag and associated release by removing the numerical suffix
      # from the rc pre-release (e.g., renaming `v0.0.1-rc.1` to `v0.0.1-rc`).
      - name: Rename RC Release Tag (Develop Branch Only)
        if: github.ref == 'refs/heads/develop'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          latest_tag=$(gh release list --limit 1 --json tagName,isPrerelease --jq '.[] | select(.isPrerelease) | .tagName')
          if [[ $latest_tag == *"-rc."* ]]; then
            new_tag=${latest_tag%-rc.*}-rc
            new_name="Release ${new_tag}"
            gh release edit "$latest_tag" --tag "$new_tag" --title "$new_name"
            git tag $new_tag $latest_tag  # Create the new tag pointing to the same commit
            git tag -d $latest_tag  # Delete the old tag locally
            git push origin $new_tag  # Push the new tag to the remote
            git push origin :refs/tags/$latest_tag  # Delete the old tag on the remote
          fi
