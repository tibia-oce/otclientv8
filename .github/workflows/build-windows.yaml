name: "Build: Windows"

on:
  workflow_dispatch:
  pull_request:
    branches:
      - master
      - develop
    paths:
      - "data/**"
      - "mods/**" 
      - "modules/**"
      - "layouts/**"
      - ".github/workflows/build-windows.yaml"
      - "src/**"
  push:
    branches:
      - master
      - develop
    paths:
      - ".github/workflows/build-windows.yaml"
      - "data/**"
      - "mods/**"
      - "modules/**"
      - "layouts/**"
      - "src/**"

env:
  PREMAKE_VERSION: 5.0.0-beta2
  MSBUILD_OPTIONS: >
    /p:Configuration=Release
    /p:Platform=x64
    /p:VcpkgEnabled=true
    /p:VcpkgEnableManifest=true
    /p:VcpkgManifestInstall=true
    /p:VcpkgConfiguration=Release

jobs:
  build:
    name: Windows Build
    runs-on: windows-2022
    steps:

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: recursive

    - name: Setup MSBuild and add to PATH
      uses: microsoft/setup-msbuild@v1.0.2

    - name: Restore artifacts and install vcpkg
      id: vcpkg-step
      run: |
        $json = Get-Content vcpkg.json -Raw | ConvertFrom-Json
        $vcpkgCommitId = $json.'builtin-baseline'
        Write-Host "vcpkg commit ID: $vcpkgCommitId"
        echo "vcpkgGitCommitId=$vcpkgCommitId" >> $env:GITHUB_OUTPUT
    
    - name: Setup vcpkg
      uses: lukka/run-vcpkg@v11
      with:
        vcpkgGitCommitId: ${{ steps.vcpkg-step.outputs.vcpkgGitCommitId }}
        vcpkgJsonIgnores: "['**/vcpkg/**', '**/browser/overlay-ports/**']"
        vcpkgDirectory: ${{ github.workspace }}/vcpkg
        runVcpkgInstall: true
      env:
        VCPKG_DEFAULT_TRIPLET: x64-windows
        VCPKG_INSTALLED_DIR: ${{ github.workspace }}/vcpkg/installed

    - name: Download and setup Premake
      run: |
        mkdir -p tools
        Invoke-WebRequest -Uri "https://github.com/premake/premake-core/releases/download/v${{ env.PREMAKE_VERSION }}/premake-${{ env.PREMAKE_VERSION }}-windows.zip" -OutFile "tools/premake.zip"
        Expand-Archive tools/premake.zip -DestinationPath tools
        cd tools
        Rename-Item "premake5.exe" -NewName "premake.exe"
        cd ..

    - name: Generate Visual Studio project files
      run: |
        ./tools/premake.exe vs2022

    - name: Build project
      run: |
        MSBuild.exe build/otclient.sln ${{ env.MSBUILD_OPTIONS }}

    - name: Create Client Package
      run: |
        mkdir -p ${{ github.workspace }}\client
        Copy-Item -Path build\bin\Release\otclient.exe -Destination ${{ github.workspace }}\client -Force
        Copy-Item -Path build\bin\Release\*.dll -Destination ${{ github.workspace }}\client -ErrorAction SilentlyContinue
        Copy-Item -Recurse -Path layouts -Destination ${{ github.workspace }}\client
        Copy-Item -Recurse -Path data -Destination ${{ github.workspace }}\client
        Copy-Item -Recurse -Path mods -Destination ${{ github.workspace }}\client
        Copy-Item -Recurse -Path modules -Destination ${{ github.workspace }}\client
        Copy-Item -Path init.lua -Destination ${{ github.workspace }}\client

    - name: Create and Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: otclient
        path: ${{ github.workspace }}\client


  # release:
  #   runs-on: ubuntu-latest
  #   needs: build
  #   steps:
  #     - name: Checkout code
  #       uses: actions/checkout@v4
  #       with:
  #         fetch-depth: 0

  #     - name: Use Node.js 20.x
  #       uses: actions/setup-node@v3
  #       with:
  #         node-version: '20.x'

  #     - name: Download build artifacts
  #       uses: actions/download-artifact@v4
  #       with:
  #         path: artifacts
  #         pattern: 'client-*'

  #     - name: List downloaded artifacts
  #       run: ls -R artifacts/

  #     # https://github.com/semantic-release/semantic-release/issues/1592#issuecomment-902533435
  #     # Semantic-release doesn't support pathing to a config file unless using a .js config:
  #     # instead copy the file to the root as a workaround to maintain workflow separation
  #     - name: Copy Release Config to Root
  #       run: |
  #         cp .github/.releaserc ./

  #     - name: Install Semantic Release
  #       run: |
  #         npm install semantic-release @semantic-release/github --save-dev
  #         npm install conventional-changelog-eslint --save-dev

  #     # Ensure that only one rc pre-release is active at a time by deleting the latest pre-release 
  #     # and its corresponding tag on the 'develop' branch. This avoids clutter from multiple rc 
  #     # releases after each merge into the develop branch.
  #     - name: Delete Existing Pre-release and Tag (Develop Branch Only)
  #       if: github.ref == 'refs/heads/develop'
  #       env:
  #         GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #       run: |
  #         latest_prerelease_tag=$(gh release list --limit 1 --json tagName,isPrerelease \
  #           --jq '.[] | select(.isPrerelease) | .tagName')

  #         if [ -n "$latest_prerelease_tag" ]; then
  #           gh release delete "$latest_prerelease_tag" --yes --cleanup-tag
  #         fi

  #     - name: Semantic Release (Dry Run for PRs)
  #       if: ${{ github.event_name == 'pull_request' }}
  #       env:
  #         GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #       run: npx semantic-release --ci --dry-run

  #     - name: Semantic Release (Full Release on Push)
  #       if: ${{ github.event_name == 'push' || github.event_name == 'workflow_dispatch' }}
  #       env:
  #         GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #         DEBUG: semantic-release:*
  #       run: |
  #         npx semantic-release --ci
  #         RELEASE_TAG=$(gh release list --limit 1 --json tagName --jq '.[0].tagName')
          
  #         # Windows artifact
  #         if [ -f "artifacts/client-windows-2022-windows-release/client.zip" ]; then
  #           gh release upload "$RELEASE_TAG" "artifacts/client-windows-2022-windows-release/client.zip" --clobber \
  #             --name "otclient-windows-${RELEASE_TAG}.zip"
  #         fi
          
  #         # Linux artifact
  #         if [ -f "artifacts/client-ubuntu-22.04-linux-release/client.tar.gz" ]; then
  #           gh release upload "$RELEASE_TAG" "artifacts/client-ubuntu-22.04-linux-release/client.tar.gz" --clobber \
  #             --name "otclient-linux-${RELEASE_TAG}.tar.gz"
  #         fi
          
  #         # macOS artifact
  #         if [ -f "artifacts/client-macOS-14-macos-release/client.zip" ]; then
  #           gh release upload "$RELEASE_TAG" "artifacts/client-macOS-14-macos-release/client.zip" --clobber \
  #             --name "otclient-macos-${RELEASE_TAG}.zip"
  #         fi

  #     # https://semantic-release.gitbook.io/semantic-release/usage/workflow-configuration#pre-release-branches
  #     # Semantic-release appends a numerical suffix to all pre-releases by default (e.g., `v0.0.1-rc.1`).
  #     # Currently, this behavior is not configurable via CLI or the release config. For improved readability 
  #     # and consistency, this step renames the tag and associated release by removing the numerical suffix
  #     # from the rc pre-release (e.g., renaming `v0.0.1-rc.1` to `v0.0.1-rc`).
  #     - name: Rename RC Release Tag (Develop Branch Only)
  #       if: github.ref == 'refs/heads/develop'
  #       env:
  #         GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #       run: |
  #         latest_tag=$(gh release list --limit 1 --json tagName,isPrerelease --jq '.[] | select(.isPrerelease) | .tagName')
  #         if [[ $latest_tag == *"-rc."* ]]; then
  #           new_tag=${latest_tag%-rc.*}-rc
  #           new_name="Release ${new_tag}"
  #           gh release edit "$latest_tag" --tag "$new_tag" --title "$new_name"
  #           git tag $new_tag $latest_tag  # Create the new tag pointing to the same commit
  #           git tag -d $latest_tag  # Delete the old tag locally
  #           git push origin $new_tag  # Push the new tag to the remote
  #           git push origin :refs/tags/$latest_tag  # Delete the old tag on the remote
  #         fi